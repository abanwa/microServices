const amqp = require("amqplib");
const logger = require("./logger");

// NOTE: This will help us to interact with the different micro services

// we will create a connection and channel to RabbitMQ so that we can consume and publish messages
let connection = null;
let channel = null;

// we will create unique exchange name
const EXCHANGE_NAME = "facebook_events";

async function connectToRabbitMQ() {
  try {
    connection = await amqp.connect(process.env.RABBITMQ_URL);

    // the connection will create a channel for us
    channel = await connection.createChannel();

    // Exchange is like a router that will route the messages to the correct queue and exchange is the exchange name, topic is the type and {durable: false} means it will not save the messages to the disk. it is the optional function
    // assertExchange ensures that exchange exist, if it does not exist, it will create a new exchange
    // { durable: false }: This option specifies whether the exchange should survive a RabbitMQ server restart. If durable: true, the exchange will be saved to disk and restored after a restart. Here, it’s set to false, meaning the exchange will not persist.
    await channel.assertExchange(EXCHANGE_NAME, "topic", { durable: false });
    logger.info("Connected to rabbit MQ");

    return channel;
  } catch (err) {
    logger.error("Error in connecting to RabbitMQ : ", err);
  }
}

// we will consume the event that was published from the post service in the deletePost in post-controller
async function consumeEvent(routingKey, callback) {
  if (!channel) {
    // if channel is not present, we will connect to our rabbitMQ which will create a channel
    await connectToRabbitMQ();
  }

  // channel.assertQueue ensures that a queue exists. If it doesn’t, it creates a new queue.
  // "": An empty string as the queue name means RabbitMQ will generate a unique name for the queue.
  // { exclusive: true }: This option makes the queue exclusive to this connection. Once the connection is closed, the queue will be deleted.
  const q = await channel.assertQueue("", { exclusive: true });

  // channel.bindQueue(): This method binds the queue to the exchange.
  // q.queue: The name of the queue (generated by RabbitMQ).
  // EXCHANGE_NAME: The name of the exchange (e.g., "facebook_events").
  // routingKey: The key used to filter messages. Only messages with a matching routing key will be routed to this queue.
  await channel.bindQueue(q.queue, EXCHANGE_NAME, routingKey);

  // channel.consume(): This method starts consuming messages from the specified queue.
  // q.queue: The name of the queue to consume messages from.
  // (msg) => { ... }: This is the callback function that processes each message.
  // msg: The message object received from RabbitMQ.
  // msg.content: The actual content of the message (a buffer).
  // msg.content.toString(): Converts the buffer to a string.
  // JSON.parse(): Parses the string content into a JavaScript object (assuming the message is in JSON format).
  // callback(content): Calls the provided callback function with the parsed message content.
  // channel.ack(msg): Acknowledges the message, telling RabbitMQ that the message has been processed and can be removed from the queue.
  channel.consume(q.queue, (msg) => {
    if (msg !== null) {
      const content = JSON.parse(msg.content.toString());
      callback(content);
      // we will acknowledge the message
      channel.ack(msg);
    }
  });

  logger.info(
    `Consume/Subscribe to event in search. the key is : ${routingKey}`
  );
}

module.exports = { connectToRabbitMQ, consumeEvent };
